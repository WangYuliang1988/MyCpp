//
// learntmpt.h
//
// 用于学习 C++ 模板相关知识
//
#ifndef _WYL_LEARN_TMPT
#define _WYL_LEARN_TMPT

//
// 模板
//
// 模板是泛型编程的基础，泛型编程即以一种独立于具体类型的方式编写代码。
//
// 考虑这样一种场景：编写一个求和函数，可以求两个整型、两个浮点型、两个双精度型的变量的和。
// 
// 按照常规写法，就需要编写三个求和函数，分别接收两个整型、浮点型、双精度型参数，而函数代码完全相同，存在代码冗余。
// 
// 通过模板，即可解决上述场景中存在的问题。而且，模板不仅可以定义函数，还可以定义类。
//

//
// 函数模板
//
// 语法格式：
//	template <typename T> return_type func_name(params) {...}
// 
// T 是类型占位符名称，一般约定用 T，但也可以用其它名称。
// 
// 注意：C/C++ 中头文件一般只进行函数声明，函数定义由源文件完成。
// 如果在头文件中进行函数定义的话，当多个源文件包含同一个头文件时，会报函数重复定义的错误。
// 
// 但是，对于函数模板，如果写在头文件中的话，则必须进行定义，不能只是声明。
// 因为函数模板的编译比较特殊，如果头文件中未进行定义的话，编译时会报无法解析外部符号错误。
//
template <typename T> T sum(T x, T y)
{
	return x + y;
}

//
// 类模板
// 
// 语法格式：
//	template <class T> class class_name {...}
// 
// T 是类型占位符名称，一般约定用 T，但也可以用其它名称。
// 
// 注意：类的成员函数即可以在类的内部定义，也可以在类的内部声明，在类的外部定义。
// 
// 但是，当在头文件中定义类模板时，若成员函数是在外部定义，则外部定义必须和类模板位于同一个头文件内。
// 
template <class T> class Math
{
public:
	// 类中直接进行定义
	T min(T x, T y)
	{
		return x < y ? x : y;
	}
	// 类中声明，外部定义，注意外部定义必须在当前头文件内
	T max(T x, T y);
};

template <class T> T Math<T>::max(T x, T y)
{
	return x > y ? x : y;
}

#endif // !_WYL_LEARN_TMPT